<!DOCTYPE html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />


<link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet-0.5.1/leaflet.css" />

<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="http://d3js.org/d3.geo.projection.v0.min.js"></script>
<script src="http://d3js.org/topojson.v0.min.js"></script>

<script src="http://cdn.leafletjs.com/leaflet-0.5.1/leaflet.js"></script>

<script src="http://libs.cartocdn.com/cartodb.js/v2/cartodb.js"></script>
<style>

#map {
  width: 960px;
  height: 700px;
 /* background-color:#6C0; /*
 /*opacity:.5;*/
}

path {
  fill: #000;
  fill-opacity: .2;
  stroke: #fff;
  stroke-width: 1.5px;
}

path:hover {
  fill: brown;
  fill-opacity: .7;
}

.myfirstline {
	
	stroke:red;
	
	}
	
.thisbubble {
	
	fill:yellow;
	opacity:.94;
	
	}
	
	

</style>

</style>


<title>Untitled Document</title>
</head>

<div id="map"></div>

<script>

// create a map in the "map" div, set the view to a given place and zoom
//var map = L.map('map').setView([45.67, -111.03], 10);  //bozeman


var map = L.map('map', {
    center: [45.67, -111.03],
    zoom: 12,
	minZoom: 1,
	maxZoom:17
});

// add an OpenStreetMap tile layer

//L.tileLayer('http://{s}.tile.cloudmade.com/f455d75240a145dab3f1b851e78aa8fa/9203/256/{z}/{x}/{y}.png', {   //cloudmade... but think I klike mapbox better

L.tileLayer('http://{s}.tiles.mapbox.com/v3/psmuts.map-5nan4cgq/{z}/{x}/{y}.png', {
    attribution: 'Map data &copy; 2011 OpenStreetMap contributors, Imagery &copy; 2011 MapBox'
}).addTo(map);


//cloudmade tiles I like.  67125, 73053, 


//add svg:g to leaflet overlay pane.  

var svg = d3.select(map.getPanes().overlayPane).append("svg"),
    g = svg.append("g").attr("class", "leaflet-zoom-hide");   //this is a class used internally by leaflet that hides overlay during zoom.  

//test line.  
	
//problems because cartodb sending points not lat/lon add this to db and use the projection you were working on and it will work.  

//get cartoDB json with paths and points...  overlay using this added overlay panels
	
d3.json("data/us-states.json", function(collection) {
  var bounds = d3.geo.bounds(collection),               //break this down what is happening.   //this takes max and min, lat lon from geography collection to set svg bounding box.  
      path = d3.geo.path().projection(project);   //detault projection is AlbersUSA

  var feature = g.selectAll("path")
      .data(collection.features)
      .enter().append("path");


//////////////////////     carto db      /////////////////////////

var sql = new cartodb.SQL({ user: 'psmuts', format: 'geojson', dp: 10});

	var circle = d3.geo.circle()
		.cx(function(d) { return d.cx; })
    	.cy(function(d) { return d.cy; })

/////   points   ////
	sql.execute("SELECT * FROM bozeman_uncontrolled WHERE the_geom IS NOT NULL", function(cartodb_collection) {
   //alert(cartodb_collection.features.number_accidents)
    bubbles = g.append("g")
			//.call(zoom)
			.selectAll("bubble")
            .data(cartodb_collection.features)
            .enter().append("path")
			.attr("d", circle)
			//.attr("class", "thisbubble")
			///.attr("cx", function(d) { return circle_projection([d.geometry.coordinates[1], d.geometry.coordinates[0]]) [0] }) 
			//.attr("cy", function(d) { return circle_projection([d.geometry.coordinates[1], d.geometry.coordinates[0]]) [1] }) 
			//.attr("r",function(d) { return d.properties.number_accidents })
			.attr("id",function (d) { return d.properties.description })
			//.attr("fill", "purple")  //fill based on some metric.  or pull from CartoDB.  
      })
      .error(function(errors) {
        // console.log('Errors! Oh no!')
      });
	
////   paths   ////

	sql.execute("SELECT * FROM bozeman_paths WHERE the_geom IS NOT NULL", function(cartodb_collection) {
 
    added_paths = g.append("g").selectAll("new_paths")
            .data(cartodb_collection.features)
            .enter().append("path")
			.attr("d", path)
      })
      .error(function(errors) {
        // console.log('Errors! Oh no!')
      });
/////    lines    /////

	sql.execute("SELECT * FROM bozeman_paths WHERE the_geom IS NOT NULL", function(cartodb_collection) {
 
    added_liness = g.append("g").selectAll("new_lines")
            .data(cartodb_collection.features)
            .enter().append("path")
			.attr("d", path)
      })
      .error(function(errors) {
        // console.log('Errors! Oh no!')
      });


	
//////////////////////     carto db      /////////////////////////

			
///// DO ANOTHER TEST AFTER THIS WHICH IS A ANOTHER LAYER ON TOP WITHOUT GEO DATA...  INDEPENDENT FO LEAFLET   See legend in US_cholorpleth
//////////////////////////////////////

  map.on("viewreset", reset);  //leaflet event....
  
  reset();

  // Reposition the SVG to cover the features.
  function reset() {
	  
    var bottomLeft = project(bounds[0]),
        topRight = project(bounds[1]);

    svg .attr("width", topRight[0] - bottomLeft[0])
        .attr("height", bottomLeft[1] - topRight[1])
        .style("margin-left", bottomLeft[0] + "px")
        .style("margin-top", topRight[1] + "px");

    g   .attr("transform", "translate(" + -bottomLeft[0] + "," + -topRight[1] + ")");

    feature.attr("d", path);
	added_paths.attr("d", path)
	
	bubbles
			.attr("cx", function(d) { return circle_projection([d.geometry.coordinates[1], d.geometry.coordinates[0]]) [0] }) 
			.attr("cy", function(d) { return circle_projection([d.geometry.coordinates[1], d.geometry.coordinates[0]]) [1] }) 
			.attr("r",function(d) { return d.properties.number_accidents})

	// alert(added_paths.attr("d", path));
	/*
	added_paths
		.attr("cx", function(d) {return  test_projection ([d.geometry.coordinates[0],d.geometry.coordinates[1]]) [0]; })
		.attr("cy", function(d) { return test_projection ([d.geometry.coordinates[0],d.geometry.coordinates[1]]) [1];})
	//will have to create var for reposition.  cx, cy, etc.... 
	*/
  }  

  // Use Leaflet to implement a D3 geographic projection.
  function project(x) {
    var point = map.latLngToLayerPoint(new L.LatLng(x[1], x[0]));
	//alert("point x,y = " + point.x + "  " +  point.y)
    return [point.x, point.y];
  }
  
  function circle_projection(coordinates) {
	  	//alert(coordinates[0] + "   " +  coordinates[1])
	   	var point = map.latLngToLayerPoint(new L.LatLng(coordinates[0], coordinates[1]));
		//alert("point x,y = " + point.x + "  " +  point.y)
    	return [point.x, point.y];
  }
  
	
  
});	


//if using leaflet.  
// add a marker in the given location, attach some popup content to it and open the popup

/*
L.marker([45.67, -111.1]).addTo(map)
    .bindPopup('A pretty CSS3 popup. <br> Easily customizable.')
    .openPopup();
*/
</script>
    
<body>
</body>
</html>